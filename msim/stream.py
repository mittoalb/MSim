"""
NTNDArray Streaming Utility for PVAccess (Server Management Version)

This module provides functionality to stream 2D NumPy arrays to EPICS PVAccess
process variables (PVs) using the NTNDArray normative type.

Handles PV conflicts and server reuse properly.
"""

import time
import numpy as np
import pvaccess as pva
from functools import wraps
import atexit
import weakref


class AdImageUtility:
    """
    Utility class for manipulating Area Detector images and NTNDArray structures.
    """
    
    # Area detector color modes values
    COLOR_MODE_MONO = 0  # [NX, NY]
    COLOR_MODE_RGB1 = 2  # [3, NX, NY]
    COLOR_MODE_RGB2 = 3  # [NX, 3, NY]
    COLOR_MODE_RGB3 = 4  # [NX, NY, 3]

    COLOR_MODES = {
        COLOR_MODE_MONO: "MONO",
        COLOR_MODE_RGB1: "RGB1",
        COLOR_MODE_RGB2: "RGB2",
        COLOR_MODE_RGB3: "RGB3",
    }

    NTNDA_DATA_FIELD_KEY_MAP = {
        np.dtype('uint8'):   'ubyteValue',
        np.dtype('int8'):    'byteValue',
        np.dtype('uint16'):  'ushortValue',
        np.dtype('int16'):   'shortValue',
        np.dtype('uint32'):  'uintValue',
        np.dtype('int32'):   'intValue',
        np.dtype('uint64'):  'ulongValue',
        np.dtype('int64'):   'longValue',
        np.dtype('float32'): 'floatValue',
        np.dtype('float64'): 'doubleValue'
    }

    PVA_DATA_TYPE_MAP = {
        np.dtype('uint8'):   pva.UBYTE,
        np.dtype('int8'):    pva.BYTE,
        np.dtype('uint16'):  pva.USHORT,
        np.dtype('int16'):   pva.SHORT,
        np.dtype('uint32'):  pva.UINT,
        np.dtype('int32'):   pva.INT,
        np.dtype('uint64'):  pva.ULONG,
        np.dtype('int64'):   pva.LONG,
        np.dtype('float32'): pva.FLOAT,
        np.dtype('float64'): pva.DOUBLE
    }

    @classmethod
    def getNtNdArrayDataFieldKey(cls, image):
        """Get NTNDA data field key for a given numpy array dtype."""
        return cls.NTNDA_DATA_FIELD_KEY_MAP.get(image.dtype)

    @classmethod
    def generateNtNdArray2D(cls, imageId, imageData, nx=None, ny=None, dtype=None, 
                           compressorName=None, extraFieldsPvObject=None):
        """Generate NTNDArray for a 2D monochrome image."""
        if extraFieldsPvObject is None:
            ntNdArray = pva.NtNdArray()
        else:
            ntNdArray = pva.NtNdArray(extraFieldsPvObject.getStructureDict())

        dataFieldKey = cls.NTNDA_DATA_FIELD_KEY_MAP.get(imageData.dtype)
        data = imageData.flatten()
        
        if not compressorName:
            pvaDataType = cls.PVA_DATA_TYPE_MAP.get(imageData.dtype)
            ny, nx = imageData.shape
            size = nx * ny * data.itemsize
            ntNdArray['compressedSize'] = size
            ntNdArray['uncompressedSize'] = size
        else:
            dtype = np.dtype(dtype)
            pvaDataType = cls.PVA_DATA_TYPE_MAP.get(dtype)
            codec = pva.PvCodec(compressorName, pva.PvInt(int(pvaDataType)))
            ntNdArray['codec'] = codec
            size = nx * ny * dtype.itemsize
            ntNdArray['uncompressedSize'] = size
            ntNdArray['compressedSize'] = len(data)

        ntNdArray['uniqueId'] = int(imageId)
        dims = [pva.PvDimension(nx, 0, nx, 1, False),
                pva.PvDimension(ny, 0, ny, 1, False)]
        ntNdArray['dimension'] = dims
        ts = pva.PvTimeStamp(time.time())
        ntNdArray['timeStamp'] = ts
        ntNdArray['dataTimeStamp'] = ts
        ntNdArray['descriptor'] = 'Image generated by PvaPy'

        ntNdArray['value'] = {dataFieldKey: data}
        attrs = [pva.NtAttribute('ColorMode', pva.PvInt(0))]
        ntNdArray['attribute'] = attrs
        
        if extraFieldsPvObject is not None:
            ntNdArray.set(extraFieldsPvObject)
            
        return ntNdArray

    @classmethod
    def replaceNtNdArrayImage2D(cls, ntNdArray, imageId, image, extraFieldsPvObject=None):
        """Replace image data in an existing NTNDArray structure."""
        dataFieldKey = cls.NTNDA_DATA_FIELD_KEY_MAP.get(image.dtype)
        pvaDataType = cls.PVA_DATA_TYPE_MAP.get(image.dtype)
        data = image.flatten()
        ntNdArray['uniqueId'] = int(imageId)

        ny, nx = image.shape
        dims = ntNdArray['dimension']
        if dims[0]['size'] != nx or dims[1]['size'] != ny:
            dims = [pva.PvDimension(nx, 0, nx, 1, False),
                    pva.PvDimension(ny, 0, ny, 1, False)]
            ntNdArray['dimension'] = dims
            size = nx * ny * data.itemsize
            ntNdArray['compressedSize'] = size
            ntNdArray['uncompressedSize'] = size
            
        ts = pva.PvTimeStamp(time.time())
        ntNdArray['timeStamp'] = ts
        ntNdArray['dataTimeStamp'] = ts

        u = pva.PvObject({dataFieldKey: [pvaDataType]}, {dataFieldKey: data})
        ntNdArray.setUnion(u)
        
        if extraFieldsPvObject is not None:
            ntNdArray.set(extraFieldsPvObject)
            
        return ntNdArray


# Global registry to track active servers and PVs
_ACTIVE_SERVERS = {}
_SERVER_LOCK = None


def _get_or_create_server():
    """Get the singleton PVA server instance."""
    global _ACTIVE_SERVERS
    
    if 'main' not in _ACTIVE_SERVERS:
        server = pva.PvaServer()
        _ACTIVE_SERVERS['main'] = {
            'server': server,
            'pvs': {}
        }
        print(f"Created new PVA server")
    
    return _ACTIVE_SERVERS['main']


def _cleanup_servers():
    """Cleanup function called at exit."""
    global _ACTIVE_SERVERS
    
    if _ACTIVE_SERVERS:
        print("\nCleaning up PVA servers...")
        for name, info in _ACTIVE_SERVERS.items():
            try:
                # Try to stop the server if it has a stop method
                if hasattr(info['server'], 'stop'):
                    info['server'].stop()
            except:
                pass
        _ACTIVE_SERVERS.clear()


# Register cleanup
atexit.register(_cleanup_servers)


def ntnda_stream(pv_name: str, *, start_uid: int = 1, allow_reuse: bool = True):
    """
    Decorator that publishes the result of a function returning a 2D NumPy array
    to a PVAccess NTNDArray process variable (PV).

    This version properly handles PV conflicts by reusing existing servers.

    Parameters
    ----------
    pv_name : str
        The name of the NTNDArray PV to publish the images to.
    start_uid : int, optional
        Starting unique identifier (UID) for NTNDArray frames. Defaults to 1.
    allow_reuse : bool, optional
        If True, reuse existing PV if already registered. Defaults to True.

    Returns
    -------
    decorator : Callable
        A decorator function that wraps another function to enable PV streaming.

    Examples
    --------
    Basic usage:
    
    >>> @ntnda_stream('SIM:IMG')
    ... def generate_image():
    ...     return np.random.randint(0, 255, (256, 256), dtype=np.uint8)
    
    With custom start UID:
    
    >>> @ntnda_stream('CAM:IMAGE', start_uid=100)
    ... def capture_frame():
    ...     return camera.read()
    
    Multiple streams (different PV names):
    
    >>> @ntnda_stream('CAM1:IMAGE')
    ... def camera1():
    ...     return cam1.read()
    
    >>> @ntnda_stream('CAM2:IMAGE')
    ... def camera2():
    ...     return cam2.read()
    """
    
    # Get or create the server
    server_info = _get_or_create_server()
    server = server_info['server']
    
    # Check if PV already exists
    if pv_name in server_info['pvs']:
        if allow_reuse:
            print(f"Reusing existing PV: {pv_name}")
            nt = server_info['pvs'][pv_name]['nt']
            uid = server_info['pvs'][pv_name]['uid']
        else:
            raise ValueError(f"PV {pv_name} already exists. Use allow_reuse=True or choose a different name.")
    else:
        # Create a dummy image to initialize the NTNDArray structure
        dummy = np.zeros((1, 1), dtype=np.uint8)
        nt = AdImageUtility.generateNtNdArray2D(0, dummy)
        
        # Try to add the record
        try:
            server.addRecord(pv_name, nt)
            print(f"Created new PV: {pv_name}")
        except pva.PvaException as e:
            if "Cannot add record" in str(e):
                raise RuntimeError(
                    f"PV '{pv_name}' is already registered in a different server.\n"
                    f"This usually happens when:\n"
                    f"  1. You ran the script before and it's still running\n"
                    f"  2. Another process is using this PV name\n"
                    f"Solutions:\n"
                    f"  - Use a different PV name\n"
                    f"  - Restart your Python session\n"
                    f"  - Use allow_reuse=True (if rerunning in same session)"
                ) from e
            else:
                raise
        
        uid = start_uid
        
        # Store in registry
        server_info['pvs'][pv_name] = {
            'nt': nt,
            'uid': uid
        }

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Get current state from registry
            pv_state = server_info['pvs'][pv_name]
            nt = pv_state['nt']
            uid = pv_state['uid']
            
            # Call the original function to get the image
            frame = np.asarray(func(*args, **kwargs))
            
            # Validate that it's a 2D array
            if frame.ndim != 2:
                raise ValueError(f"Expected 2-D image, got shape {frame.shape}")

            # Replace the image in the NTNDArray structure
            AdImageUtility.replaceNtNdArrayImage2D(nt, uid, frame)

            # Update the server PV with the new image
            server.update(pv_name, nt)

            # Increment and store the frame UID
            pv_state['uid'] = uid + 1

            # Return the frame (allows chaining)
            return frame
            
        return wrapper
    return decorator


def list_active_pvs():
    """
    List all active PVs in the current session.
    
    Returns
    -------
    list
        List of active PV names
    """
    global _ACTIVE_SERVERS
    
    if 'main' in _ACTIVE_SERVERS:
        pvs = list(_ACTIVE_SERVERS['main']['pvs'].keys())
        print(f"Active PVs ({len(pvs)}):")
        for pv in pvs:
            uid = _ACTIVE_SERVERS['main']['pvs'][pv]['uid']
            print(f"  - {pv} (next UID: {uid})")
        return pvs
    else:
        print("No active PVA server")
        return []


def reset_pv(pv_name: str):
    """
    Reset the UID counter for a specific PV.
    
    Parameters
    ----------
    pv_name : str
        The PV name to reset
    """
    global _ACTIVE_SERVERS
    
    if 'main' in _ACTIVE_SERVERS and pv_name in _ACTIVE_SERVERS['main']['pvs']:
        _ACTIVE_SERVERS['main']['pvs'][pv_name]['uid'] = 1
        print(f"Reset UID counter for {pv_name}")
    else:
        print(f"PV {pv_name} not found")


def cleanup_all_pvs():
    """
    Cleanup all PVs and servers.
    Call this to fully reset the streaming system.
    """
    _cleanup_servers()
    print("All PVs and servers cleaned up")


if __name__ == '__main__':
    """
    Example usage demonstrating conflict handling.
    """
    import sys
    
    # Create a streaming function
    @ntnda_stream('TEST:IMAGE')
    def generate_noise():
        """Generate a random noise image."""
        return np.random.randint(0, 255, (512, 512), dtype=np.uint8)
    
    print("Starting NTNDArray streaming to 'TEST:IMAGE'")
    print("This version properly handles PV conflicts")
    print("Press Ctrl+C to stop")
    print("-" * 50)
    
    try:
        frame_count = 0
        while True:
            img = generate_noise()
            frame_count += 1
            print(f"\rStreamed frame {frame_count} - shape: {img.shape}, dtype: {img.dtype}", end='')
            sys.stdout.flush()
            time.sleep(0.1)  # 10 fps
    except KeyboardInterrupt:
        print(f"\n\nStopped after {frame_count} frames")
        print("\nActive PVs:")
        list_active_pvs()